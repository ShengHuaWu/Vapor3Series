## Vapor 3 Series I - CRUD with Controllers
As an iOS developer, I am super excited that Apple made Swift open-sourced in 2015.
Not only does it mean there will be more interesting features, but we are able to run Swift on Linux machines as well.
More importantly, the later one brings us the possibility to write a server with Swift.
Currently, there are couple of different server side Swift frameworks, such as Vapor, Perfect, and Kitura.
The reason why I choose Vapor 3 in this article is that it supports [SwiftNIO](https://github.com/apple/swift-nio) quickly.
As a result, Vapor 3 provides succinct asynchronous APIs and it's a very good chance for me to practice asynchronous programming.
For the purpose of this article, I am going to demonstrate how to build RESTful endpoints with Vapor 3.

### Preparation
If you haven't installed Vapor yet, please follow [this instruction](https://docs.vapor.codes/3.0/install/macos/) to install Vapor properly.
After installation succeeds, we can generate our new project folder with [Vapor's toolbox new](https://docs.vapor.codes/3.0/getting-started/toolbox/#new) command.
```
vapor new CRUDControllers
```
Since we don't need the model and controller templates created by the toolbox, please delete everything inside the `Models` and `Controllers` folders with the following commands.
```
cd CRUDControllers
rm -rf Sources/App/Models/
rm -rf Sources/App/Controllers/
```
Besides, we should remove the useless code before trying to build the project.
First of all, open `Sources/App/configure.swift` file, and remove the following line.
```
migrations.add(model: Todo.self, database: .sqlite)
```
Secondly, go to `Sources/App/router.swift` file, and remove the following lines.
```
// Example of configuring a controller		
let todoController = TodoController()		
router.get("todos", use: todoController.index)		
router.post("todos", use: todoController.create)		
router.delete("todos", Todo.parameter, use: todoController.delete)
```
Finally, we can generate the Xcode project file with `vapor xcode -y`, and this command will open `CRUDControllers.xcodeproj` automatically. We can select `Run` scheme and the project should be built successfully.
![run_scheme](../Resources/CRUDControllers/run_scheme.png)

Before creating our model type, there are couple of important things needs mentioning inside `configure.swift`.
Throughout this article, we are going to use an in-memory SQLite database, so we can keep the default provider `FluentSQLiteProvider` and the database configurations generated by the toolbox.

### Model
It's best practice to create our model file outside of Xcode.
This lets Swift Package Manager, which is used by Vapor's toolbox, ensure that the file links to the correct target.
Let's create our `User` model file and regenerate the Xcode project file with the following commends.
```
mkdir Sources/App/Models
touch Sources/App/Models/User.swift
vapor xcode -y
```

Our `User` model will have three properties for now, which are `id`, `name`, and `username`.
Furthermore, as I mentioned before, our `User` model will be stored in a SQLite database.
Therefore, open the `User.swift` with Xcode, and add the following lines into the file.
```
import Vapor
import FluentSQLite

final class User: Codable {
    var id: Int?
    var name: String
    var username: String

    init(name: String, username: String) {
        self.name = name
        self.username = username
    }
}

extension User: SQLiteModel {}
extension User: Migration {}
```
The reason why our `User` model conforms `Migration` protocol is that this protocol is used to create a table for the model in the database.
Moreover, the table should be created when the application starts.
Let's switch to `configure.swift`, and add the following line before `services.register(migrations)`.
```
migrations.add(model: User.self, database: .sqlite)
```
Migrations should only run once.
If they have run in a database, they will never be executed again.
However, since we are using an in-memory database right now, the migration will be executed every time the application starts.

Considering that our CRUD endpoints should be able to receive JSON data as the HTTP body and return the responses with the JSON format, Vapor provides `Content` protocol, which allows us to convert the model to the JSON format.
Since our `User` model has already conformed `Codable` protocol, all we have to do is appending the following line at the bottom of `User.swift`.
```
extension User: Content {}
```

Finally, in order to retrieve `User` model more easily, add the following line below the `extension User: Content {}`
```
extension User: Parameter {}
```

At this point, we finish our `User` model. Please try to build and run the application, in order to make sure everything works fine.

### Controller
